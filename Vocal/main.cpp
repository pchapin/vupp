/****************************************************************************
FILE      : main.cpp
SUBJECT   : Main program for vocal compiler.
PROGRAMMER: (C) Copyright 2003 by Peter Chapin

Please send comments or bug reports to

     Peter Chapin
     Vermont Technical College
     Williston, VT 05495
     PChapin@vtc.vsc.edu
****************************************************************************/

#include "node-types.h"
#include <iostream>
#include <fstream>
#include <stdio.h>


std::ofstream output;

extern stmt_node *root_node;


extern int yyparse();
extern FILE *yyin;

int main(int argc, char **argv)
{
 
  if (argc == 1) {
    std::cout << "Usage: " << argv[0] << " filename.vcl" << std::endl;
  }
  else {
    // Assume the second command line argument is the filename.
    if (!(yyin = fopen(argv[1], "r"))) {
      std::cout << "Error opening " << argv[1] << "!!!" << std::endl;
      return 1;
    }
    yyparse();
    // Try to open the output file.
    std::string output_filename(argv[1]);
    // Get rid of the vcl extension, if we can find it.
    int ext_location = output_filename.find(".vcl");
    if (ext_location > 0) {
      output_filename.erase(ext_location, output_filename.length() - ext_location);
    }
    output_filename += ".vas";
    output.open(output_filename.c_str());
    if (output.bad()) {
      std::cout << "Error opening " << output_filename << "!!!" << std::endl;
      return 2;
    }

    // If we get here, the input file has been parsed and the output file
    // has been opened.  
    
    // Send the boilerplate.
    output << "; Code generated by vocal compiler." << std::endl;
    output << "    ORG 0x0000" << std::endl;
    output << "    jmp @code_start" << std::endl;
    // Generate locations for variables.
    for (std::map<std::string, symbol_attrs>::iterator myit = symbol_table.begin(); 
	 myit != symbol_table.end(); myit++) {

      // See how much storage we need for this type.
      switch(myit->second.vartype) {
      case tINT:
	// Ints only need one word.
	output << "_" << myit->first << ": DW 0" << std::endl;
	break;
      case tLONG:
	// Longs need two words.
	output << "_" << myit->first << ": DW 0" << std::endl
	       << "    DW 0" << std::endl;
	break;
      case tINTARRAY:
	// An array of ints needs one word per element.
	// Assuming there is at least 1 element.
	output << "_" << myit->first << ": DW 0" << std::endl;
	for (int i = 1; i < myit->second.num_elements; ++i) {
	  output << "    DW 0" << std::endl;
	}
	break;
      case tLONGARRAY:
	// An array of longs needs two words per element.
	// Assuming there is at least 1 element.
	output << "_" << myit->first << ": DW 0" << std::endl
	       << "    DW 0" << std::endl;
	for (int i = 1; i < myit->second.num_elements; ++i) {
	  output << "    DW 0" << std::endl
		 << "    DW 0" << std::endl;
	}
	break;
      default:
	std::cerr << "ERROR: " << myit->first << " has unknown type!\n" << std::endl;
      }

    }
    // Put any initialization code here.
    output << "@code_start:" << std::endl
           << "    ; Set up the stack pointer." << std::endl
	   << "    copy 0x8000, r7" << std::endl;
    // Make the assembly.
    root_node->generate();
    output.close();
    fclose(yyin);
  }
  
  return 0;
}
